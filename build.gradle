// (C) Copyright 2025 Hewlett Packard Enterprise Development LP

import java.text.SimpleDateFormat
import org.gradle.api.publish.maven.MavenPublication
import groovy.util.XmlSlurper
import org.gradle.api.GradleException
import org.gradle.api.tasks.testing.Test
import org.gradle.testing.jacoco.tasks.JacocoReport

buildscript {
    repositories {
        mavenLocal()
        mavenCentral()
        maven { url "https://plugins.gradle.org/m2/" }
	maven { url "https://nexus.bertramlabs.com/content/repositories/snapshots" }
        maven { url "https://nexus.bertramlabs.com/content/repositories/releases" }
	maven { url "https://nexus.bertramlabs.com/content/repositories/publicReleases" }
    }
    dependencies {
        classpath "com.morpheusdata:morpheus-plugin-gradle:$morpheusGradleVersion"
        classpath "com.bertramlabs.plugins:asset-pipeline-gradle:$assetPipelineVersion"
    }
}

plugins {
    id 'java'
    id 'maven-publish'
    id 'groovy'
    id 'idea'
    id 'com.github.johnrengelman.shadow' version '8.1.1'
    id 'com.jfrog.artifactory' version "5.+"
    id 'org.sonarqube' version '5.1.0.4882'
    id 'codenarc'
    id 'jacoco'
    id 'com.adarshr.test-logger' version '4.0.0'
}

apply plugin: 'com.morpheusdata.morpheus-plugin-gradle'
apply plugin: 'java'
apply plugin: 'groovy'
apply plugin: 'idea'
apply plugin: 'com.github.johnrengelman.shadow'
apply plugin: 'asset-pipeline'
group = 'com.hpe.scvmm'

// Include required files in the JAR
processResources {
	from('NOTICE') {
		into('META-INF')
	}
}

ext {
    baseVersion = project.version.toString()
    if (baseVersion.endsWith("-SNAPSHOT")) {
        def ts = new SimpleDateFormat("yyyyMMdd.HHmmss").format(new Date())
        def buildNum = System.getenv("BUILD_NUMBER") ?: "1"
        finalVersion = baseVersion.replace("-SNAPSHOT", "-${ts}-${buildNum}")
    } else {
        finalVersion = baseVersion
    }
}
version = finalVersion
ext.isReleaseVersion = !version.endsWith("SNAPSHOT")

java {
    sourceCompatibility = JavaVersion.toVersion('1.11')
    targetCompatibility = JavaVersion.toVersion('1.11')
}
ext.versions = [
    jackson: '2.15.2',
    commonsCompress: '1.26.2',
    httpClient: '4.5.3',
    httpCore: '4.4.5',
    rxJava: '3.1.7',
    byteBuddy: '1.9.3',
    objenesis: '2.6',
    cglib: '3.2.12',
    commonsNet: '3.6',
    commonsBeanUtils: '1.9.3',
    javaTar: '0.0.1',
]


repositories {
    mavenLocal()
    mavenCentral()
    maven { url "https://plugins.gradle.org/m2/" }
    maven { url "https://maven.google.com" }
    maven { url "https://nexus.bertramlabs.com/content/repositories/snapshots" }
    maven { url "https://nexus.bertramlabs.com/content/repositories/releases" }
    maven { url "https://nexus.bertramlabs.com/content/repositories/publicReleases" }
}


configurations {
    provided
}

dependencies {
    provided "com.morpheusdata:morpheus-plugin-api:$morpheusApiVersion"
	
    provided "org.codehaus.groovy:groovy-all:$groovyVersion"
    implementation 'commons-beanutils:commons-beanutils:1.11.0'
    implementation "org.slf4j:slf4j-api:$slf4jVersion"
    implementation "org.slf4j:slf4j-parent:$slf4jVersion"
    implementation 'commons-net:commons-net:3.9.0'
    implementation("com.bertramlabs.plugins:karman-core:${karmanVersion}") {
        exclude module: 'groovy-all'
    }

    // Include morpheus-core and it's dependencies
    testImplementation 'io.reactivex.rxjava3:rxjava:3.1.7'
    testImplementation 'org.apache.httpcomponents:httpclient:4.5.13'
    testImplementation 'org.apache.httpcomponents:httpcore:4.4.5'
    testImplementation "org.slf4j:slf4j-parent:$slf4jVersion"

    testImplementation "org.codehaus.groovy:groovy-all:$groovyVersion"
    testImplementation 'net.bytebuddy:byte-buddy:1.9.3'
    testImplementation 'org.objenesis:objenesis:2.6'
    testImplementation platform("org.spockframework:spock-bom:$spockVersion")
    testImplementation "org.spockframework:spock-core"
    testImplementation "org.spockframework:spock-junit4"  // you can remove this if your code does not rely on old JUnit 4 rules
    testImplementation 'cglib:cglib-nodep:3.2.12'


    // JSON processing dependencies - use platform BOM
    testImplementation platform("com.fasterxml.jackson:jackson-bom:${versions.jackson}")
    testImplementation "com.fasterxml.jackson.core:jackson-core"
    testImplementation "com.fasterxml.jackson.core:jackson-databind"
    testImplementation "com.fasterxml.jackson.core:jackson-annotations"
}


sourceSets {
    main {
        compileClasspath += configurations.provided
    }
}

// ===== STATIC ANALYSIS =====
codenarc {
    toolVersion = '3.5.0'
    configFile = file('config/codenarc/codenarc.groovy')
    reportFormat = 'html'
    sourceSets = [sourceSets.main]
    ignoreFailures = true  // This makes CodeNarc not fail the build
    maxPriority1Violations = -1  // No limit on P1 violations (handled in our custom reporting)
    maxPriority2Violations = -1  // No limit on P2 violations (handled in our custom reporting)
    maxPriority3Violations = -1  // No limit on P3 violations (handled in our custom reporting)
}

codenarcMain {
    reports {
        html {
            required = true
            outputLocation = layout.buildDirectory.file('reports/codenarc/main.html')
        }
        xml {
            required = true
            outputLocation = layout.buildDirectory.file('reports/codenarc/main.xml')
        }
    }
    ignoreFailures = true  // Also set at task level for extra safety
    source = sourceSets.main.allGroovy
}

// ===== ANSI COLOR CONSTANTS =====
ext.colors = [
	RESET: "\u001B[0m",
	GREEN: "\u001B[32m",
	RED: "\u001B[31m",
	YELLOW: "\u001B[33m",
	ORANGE: "\u001B[38;5;208m", // Using 256-color mode for orange
	BOLD: "\u001B[1m"
]

def configureXmlParser() {
    def parser = new XmlSlurper()
    parser.setFeature("http://apache.org/xml/features/disallow-doctype-decl", false)
    parser.setFeature("http://xml.org/sax/features/external-general-entities", false)
    parser.setFeature("http://xml.org/sax/features/external-parameter-entities", false)
    parser.setFeature("http://apache.org/xml/features/nonvalidating/load-dtd-grammar", false)
    parser.setFeature("http://apache.org/xml/features/nonvalidating/load-external-dtd", false)
    parser.setProperty("http://javax.xml.XMLConstants/property/accessExternalDTD", "")
    return parser
}

//Set plugin metadata information here that gets written into the jar
jar {
    manifest {
        attributes(
	    'Plugin-Class': 'com.morpheusdata.scvmm.ScvmmPlugin',
	    'Plugin-Version': archiveVersion,
	    'Morpheus-Name': 'SCVMM',
	    'Morpheus-Organization': 'morpheus',
	    'Morpheus-Code': 'morpheus-scvmm-plugin',
	    'Morpheus-Description': 'Plugin for System Center Virtual Machine Manager',
	    'Morpheus-Logo': 'assets/scvmm.svg',
	    'Morpheus-Logo-Dark': 'assets/scvmm-dark.svg',
	    'Morpheus-Labels': 'Plugin',
	    'Morpheus-Repo': 'https://github.com/HewlettPackard/morpheus-scvmm-plugin',
	    'Morpheus-Min-Appliance-Version': "8.0.3"
	)
   }
}


sonarqube {
    properties {
        property "sonar.projectKey", "Morpheus-scvmm-Plugin"
        property "sonar.projectName", "morpheus-scvmm-plugin"
        property "sonar.sources", "src/main/groovy"
        property "sonar.tests", "src/test/groovy"
        property "sonar.java.binaries", "build/classes/groovy/main"
        property "sonar.coverage.jacoco.xmlReportPaths", "build/reports/jacoco/test/jacocoTestReport.xml"
    }
}

test {
    testLogging {
        exceptionFormat = 'full'
        showStandardStreams = true
    }
}

shadowJar {
    archiveClassifier.set('all')
}

assets {
    packagePlugin = false //leave this false for plugins
}
// Get environment variables or project properties for sensitive information
def getEnvOrProperty = { envKey, propKey ->
    return System.getenv(envKey) ?: project.findProperty(propKey) ?: ''
}

tasks.assemble.dependsOn tasks.shadowJar

tasks.register('console', JavaExec) {
    dependsOn 'classes'
    main = 'groovy.ui.Console'
    classpath = sourceSets.main.compileClasspath + sourceSets.main.runtimeClasspath
}

final gitCommitId = providers.exec {
	commandLine('git', 'rev-parse', 'HEAD')
}.standardOutput.asText.get()

final gitBranchName = providers.exec {
	commandLine('git', 'rev-parse', '--abbrev-ref', 'HEAD')
}.standardOutput.asText.get()

def getEnvOrProperty(final String envVar, final String propertyKey) {
	return System.getenv(envVar) ?: project.findProperty(propertyKey)
}

artifactory {
    publish {
        // Define the Artifactory URL for publishing artifacts
        contextUrl = getEnvOrProperty('ARTIFACTORY_URL', 'https://hpeartifacts.jfrog.io/artifactory')
        // Define the project repository to which the artifacts will be published
	    repository {
               // Set the Artifactory repository key
	       repoKey = 'morpheus-plugins'
	       // Specify the publisher username
	       username = getEnvOrProperty('ARTIFACTORY_USER', 'artifactory_user')
	       // Provide the publisher password
	       password = getEnvOrProperty('ARTIFACTORY_PASSWORD', 'artifactory_password')
	    }

		// Include all configured publications for all the modules
	    defaults {
                publications('mavenJava')
	        publishArtifacts = true
	        publishPom = true
                publishBuildInfo = false
	        properties = [
		    'commit_id': gitCommitId,
	            'branch'   : gitBranchName,
		    ]
	    }

     }
}

publishing {
    publications {
        mavenJava(MavenPublication) {
            artifact(tasks.named("shadowJar"))
	        pom {
	            name.set("morpheus-scvmm-plugin")
		    description.set("scvmm plugins for Morpheus")
		    url.set("https://github.com/HewlettPackard/morpheus-scvmm-plugin")
	        }
            }
	}
}

tasks.register("uploadToArtifactory") {
    dependsOn tasks.shadowJar
    dependsOn tasks.jar

    doLast {
	def artifactId = "morpheus-scvmm-plugin"
        def jarFile = tasks.named("jar").get().archiveFile.get().asFile
        def shadowFile = tasks.named("shadowJar").get().archiveFile.get().asFile
	// --- SNAPSHOT handling ---
	def uploadBaseVersion = project.ext.baseVersion
	def timestampedVersion = project.ext.finalVersion

	// --- Generate a minimal POM manually ---
	def pomFile = file("${buildDir}/publications/mavenJava/${artifactId}-${uploadBaseVersion}.pom")
	pomFile.parentFile.mkdirs()
	pomFile.text = """<project xmlns="http://maven.apache.org/POM/4.0.0"
          xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
          xsi:schemaLocation="http://maven.apache.org/POM/4.0.0
          http://maven.apache.org/xsd/maven-4.0.0.xsd">
          <modelVersion>4.0.0</modelVersion>
          <groupId>com.hpe.ibm</groupId>
          <artifactId>${artifactId}</artifactId>
          <version>${uploadBaseVersion}</version>
          <packaging>jar</packaging>
          <name>${artifactId}</name>
          <description>scvmm plugin for Morpheus</description>
          <url>https://github.com/HewlettPackard/morpheus-scvmm-plugin</url>
        </project>"""

	def repoKey = "morpheus-plugins"
        def buildName = artifactId
	def buildNumber = System.getenv("BUILD_NUMBER") ?: System.currentTimeMillis().toString()
	def versionStr = project.version.toString()
	def targetProps = "commit_id=${gitCommitId};branch=${gitBranchName}"

	def artUrl = System.getenv("ARTIFACTORY_URL")
	def artUser = System.getenv("ARTIFACTORY_USER")
	def artPass = System.getenv("ARTIFACTORY_PASSWORD")
	if (!artUrl || !artUser || !artPass) {
            throw new GradleException("Artifactory credentials (URL, USER, PASSWORD) must be set in environment")
	}
	// --- Always use SNAPSHOT folder, but timestamped file names ---
	def targetDir = "${repoKey}/com/morpheusdata/googlecloudplatform/${artifactId}/${uploadBaseVersion}"

	// --- Call JFrog CLI directly (no shell) ---
	exec {
	    commandLine "jfrog", "rt", "bce", buildName, buildNumber
	}
	exec {
	    commandLine "jfrog", "rt", "bag", buildName, buildNumber
        }
	exec {
	    commandLine "jfrog", "rt", "u",
		jarFile.absolutePath,
		"${targetDir}/${artifactId}-${timestampedVersion}.jar",
	        "--url=${artUrl}",
		"--user=${artUser}",
	        "--password=${artPass}",        
                "--target-props=${targetProps}",
		"--build-name=${buildName}",
		"--build-number=${buildNumber}"
	}
	exec {
            commandLine "jfrog", "rt", "u", 
                shadowFile.absolutePath,
		"${targetDir}/${artifactId}-${timestampedVersion}-all.jar",
		"--url=${artUrl}",
		"--user=${artUser}",
		"--password=${artPass}",
		"--target-props=${targetProps}",
		"--build-name=${buildName}",
		"--build-number=${buildNumber}"
	}
	exec {
            commandLine "jfrog", "rt", "u",
		pomFile.absolutePath,
		"${targetDir}/${artifactId}-${timestampedVersion}.pom",
		"--url=${artUrl}",
		"--user=${artUser}",
		"--password=${artPass}",
		"--target-props=${targetProps}",
		"--build-name=${buildName}",
		"--build-number=${buildNumber}"
	}
	exec {
	    commandLine "jfrog", "rt", "bp",
		buildName, buildNumber,
		"--url=${artUrl}",
		"--user=${artUser}",
		"--password=${artPass}"
        }
    }
	// prevent Gradle warning
    outputs.upToDateWhen { false }
}

// Common method to display report locations
def displayReportLocations(buildDir) {
	println "Test Report Locations:"
	println "----------------------------------------"

    def codenarcHtml = file("${buildDir}/reports/codenarc/main.html")

    if (codenarcHtml.exists()) {
        println "  CodeNarc Report:         file://${codenarcHtml.absolutePath}"
    }
       /*
        def testHtml = file("${buildDir}/reports/tests/test/index.html")
        def integrationHtml = file("${buildDir}/reports/tests/integrationTest/index.html")
        def jacocoHtml = file("${buildDir}/reports/jacoco/test/html/index.html")

        if (testHtml.exists()) {
                 println "  Unit Test Report:        file://${testHtml.absolutePath}"
        }
        if (integrationHtml.exists()) {
                 println "  Integration Test Report: file://${integrationHtml.absolutePath}"
        }
        if (jacocoHtml.exists()) {
                println "  Coverage Report:         file://${jacocoHtml.absolutePath}"
        }
        */
    println ""
}

tasks.register('testSummary') {
    description = 'Generate test summary from results (no test execution)'
    group = 'verification'
    dependsOn codenarcMain

    doFirst {
        println "\n" + "=" * 120
        println "         TEST RESULTS SUMMARY       "
        println "=" * 120
    }

    doLast {
        def buildDir = layout.buildDirectory.asFile.get()
        println "DEBUG: Build Dir: ${layout.buildDirectory.asFile.get().absolutePath}"
        println "DEBUG: main.html exists? " + file("${layout.buildDirectory.asFile.get()}/reports/codenarc/main.html").exists()
        println "DEBUG: main.xml exists? " + file("${layout.buildDirectory.asFile.get()}/reports/codenarc/main.xml").exists()
               /*
                // 1. FIRST: Show detailed test case results (consolidated table only)
                println "\n1. TEST EXECUTION RESULTS"
                println "=" * 120
                def unitTestResults = parseTestResultsFromDir("${buildDir}/test-results/test", "Unit Tests")
                def integrationTestResults = parseTestResultsFromDir("${buildDir}/test-results/integrationTest", "Integration Tests")
                def totalResults = displayTestResultsSummary(unitTestResults, integrationTestResults)

                // 2. SECOND: Show code coverage details
                println "\n2. CODE COVERAGE ANALYSIS (JACOCO)"
                println "=" * 120
                def coverageData = displayCoverageResults(buildDir, false)
               */

         // 3. THIRD: Show CodeNarc static analysis
         println "\n3. STATIC CODE ANALYSIS (CODENARC)"
         println "=" * 120
         def codenarcData = displayCodenarcResults(buildDir)

         // 4. All report locations consolidated at the end
         println "\n4. GENERATED REPORTS"
         println "=" * 120
         displayReportLocations(buildDir)
    }
}

// Common method to parse CodeNarc report data
def parseCodenarcReport(buildDir) {
    def codenarcData = [
        totalViolations: 0,
        priority1: 0,
        priority2: 0,
        priority3: 0,
        filesAnalyzed: 0,
        reportExists: false,
        fileViolations: [:] // Map to track violations per file
     ]

     def codenarcHtml = file("${buildDir}/reports/codenarc/main.html")
     def codenarcXml = file("${buildDir}/reports/codenarc/main.xml")

     if (codenarcHtml.exists()) {
         codenarcData.reportExists = true
         // Try to parse XML report if available for more accurate data
         if (codenarcXml.exists()) {
                        try {
                                def parser = configureXmlParser()
                                def codenarc = parser.parse(codenarcXml)

                // Get files analyzed count from PackageSummary or Package totalFiles attribute
                def packageSummary = codenarc.PackageSummary
                if (packageSummary.size() > 0) {
                    codenarcData.filesAnalyzed = (packageSummary[0].@totalFiles.toString() ?: "0") as Integer
                } else {
                    // Fallback to Package element if PackageSummary not found
                    def packages = codenarc.Package
                    if (packages.size() > 0) {
                        codenarcData.filesAnalyzed = (packages[0].@totalFiles.toString() ?: "0") as Integer
                    }
                }

                // Parse package and file information for violations
                                codenarc.Package.each { pkg ->
                                        def pkgPath = pkg.@path?.toString() ?: ""

                                        pkg.File.each { file ->
                                                codenarcData.filesAnalyzed++
                                                def fileName = file.@name?.toString() ?: "Unknown"
                                                def filePath = pkgPath ? "${pkgPath}/${fileName}" : fileName

                                                def fileViolations = [
                                                        total: 0,
                                                        priority1: 0,
                                                        priority2: 0,
                                                        priority3: 0
                                                ]
                                                // Count violations for this file
                                                file.Violation.each { violation ->
                                                        codenarcData.totalViolations++
                                                        fileViolations.total++

                                                        def priority = violation.@priority?.toString() ?: "3" // Default to medium if unspecified
                                                        switch(priority) {
                                                                case '1':
                                                                        codenarcData.priority1++
                                                                        fileViolations.priority1++
                                                                        break
                                                                case '2':
                                                                        codenarcData.priority2++
                                                                        fileViolations.priority2++
                                                                        break
                                                                case '3':
                                                                        codenarcData.priority3++
                                                                        fileViolations.priority3++
                                                                        break
                                                                default:
                                                                        codenarcData.priority3++ // Treat unknown priority as medium
                                                                        fileViolations.priority3++
                                                        }
                                                }

                                                // Only add files with violations to the map
                                                if (fileViolations.total > 0) {
                                                        codenarcData.fileViolations[filePath] = fileViolations
                                                }
                                        }
                                }
                        } catch (Exception e) {
                                // Fallback to basic parsing if XML parsing fails
                                codenarcData.totalViolations = -1 // Indicates XML parsing failed
                        }
                }
        }

        return codenarcData
}

// Common method to display CodeNarc results
def displayCodenarcResults(buildDir) {
        // Using colors from the common colors map
        def codenarcData = parseCodenarcReport(buildDir)

        if (codenarcData.reportExists) {
                if (codenarcData.totalViolations >= 0) {
                        println "  Files Analyzed:          ${codenarcData.filesAnalyzed}"

                        // Format total violations count with color if high
                        def totalViolations = codenarcData.totalViolations
                        def totalViolationsStr = totalViolations > 1000 ? "${colors.BOLD}${totalViolations}${colors.RESET}" : "${totalViolations}"
                        println "  Total Violations:        ${totalViolationsStr}"

                        // Only show P1/P2/P3 counts if there are violations
                        if (totalViolations > 0) {
                                // Format priority counts with requested colors: P1 red, P2 orange, P3 yellow
                                def p1Str = codenarcData.priority1 > 0 ? "${colors.RED}${codenarcData.priority1}${colors.RESET}" : "${codenarcData.priority1}"
                                def p2Str = codenarcData.priority2 > 0 ? "${colors.ORANGE}${codenarcData.priority2}${colors.RESET}" : "${codenarcData.priority2}"
                                def p3Str = codenarcData.priority3 > 0 ? "${colors.YELLOW}${codenarcData.priority3}${colors.RESET}" : "${codenarcData.priority3}"

                                println "  Priority 1 (Critical):   ${p1Str}"
                                println "  Priority 2 (High):       ${p2Str}"
                                println "  Priority 3 (Medium):     ${p3Str}"

                                // Provide status assessment with consistent color scheme

                                if (codenarcData.priority1 > 0) {
                                        println "  Status:                  ${colors.BOLD}${colors.RED}CRITICAL VIOLATIONS FOUND${colors.RESET}"
                                } else if (codenarcData.priority2 > 0) {
                                        println "  Status:                  ${colors.BOLD}${colors.ORANGE}HIGH PRIORITY VIOLATIONS FOUND${colors.RESET}"
                                } else {
                                        println "  Status:                  ${colors.BOLD}${colors.YELLOW}MEDIUM PRIORITY VIOLATIONS FOUND${colors.RESET}"
                                }

                                // Display violations per file - optimized layout with file names only
                                println ""
                                println  "-" * 120

                                // Get the max width needed for the file name column
                                def maxFileNameWidth = 0
                                codenarcData.fileViolations.keySet().each { path ->
                                        def fileName = path.contains('/') ? path.substring(path.lastIndexOf('/') + 1) : path
                                        maxFileNameWidth = Math.max(maxFileNameWidth, fileName.length())
                                }
                                // Use reasonable column width based on terminal size
                                maxFileNameWidth = Math.min(Math.max(maxFileNameWidth, 30), 50) // Min 30, max 50 chars
                                // Print header with adjusted widths and colored labels
                                // Calculate actual table width based on column widths and separators
                                def tableWidth = maxFileNameWidth + 4 + 4 + 4 + 5 + 8 // columns + separator spaces and bars

                                println String.format("  %-${maxFileNameWidth}s | %8s | %8s | %8s | %7s",
                                        "File",
                                        "P1${colors.RESET}",
                                        "P2${colors.RESET}",
                                        "P3${colors.RESET}",
                                        "Total")
                                println "-" * 120

                                // Sort files by total violations (descending)
                                def sortedFiles = codenarcData.fileViolations.sort { -it.value.total }

                                // Display all files with violations
                                sortedFiles.each { filePath, violations ->
                                        // Extract just the file name without path for cleaner output
                                        def fileName = filePath.contains('/') ? filePath.substring(filePath.lastIndexOf('/') + 1) : filePath
                                        if (fileName.length() > maxFileNameWidth) {
                                                fileName = fileName.substring(0, maxFileNameWidth - 3) + "..."
                                        }

                                        // Format numbers as strings first for consistent formatting
                                        def totalStrFormatted = String.format("%5d", violations.total)
                                        def p1StrFormatted = String.format("%4d", violations.priority1)
                                        def p2StrFormatted = String.format("%4d", violations.priority2)
                                        def p3StrFormatted = String.format("%4d", violations.priority3)

                                        // Apply colors: P1 in red, P2 in orange, P3 in yellow
                                        if (violations.total > 100) totalStrFormatted = "${colors.BOLD}${totalStrFormatted}${colors.RESET}"
                                        if (violations.priority1 > 0) p1StrFormatted = "${colors.RED}${p1StrFormatted}${colors.RESET}"

                                        // Use ORANGE from common colors map
                                        if (violations.priority2 > 0) p2StrFormatted = "${colors.ORANGE}${p2StrFormatted}${colors.RESET}"

                                        if (violations.priority3 > 0) p3StrFormatted = "${colors.YELLOW}${p3StrFormatted}${colors.RESET}"

                                        println String.format("  %-${maxFileNameWidth}s | %s | %s | %s | %s",
                                                fileName,
                                                p1StrFormatted,
                                                p2StrFormatted,
                                                p3StrFormatted,
                                                totalStrFormatted)
                                }
                        } else {
                                println "  Status:                  NO VIOLATIONS FOUND"
                        }
                } else {
                        println "  Status:                  REPORT AVAILABLE (detailed parsing unavailable)"
                }
        println "=" * 120
                println ""
        }

        return codenarcData
}

